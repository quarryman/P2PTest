<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
    <head>
        <title>DirtyShare</title>
        <LINK REL="SHORTCUT ICON" HREF="/public/favicon.ico" /> 
        <meta name="keywords" content="node, nodejs, javascript, p2p, filesharing, webp2p, web peer to peer, p2pweb, open source" />
		<meta name="description" content="DirtyShare is a proof of concept Peer to Peer filesharing system written in pure Javascript with Socket.io and Node.js." />
        <link href="/public/style.css" rel="stylesheet" type="text/css" media="screen" />
        <link href='http://fonts.googleapis.com/css?family=Trade+Winds' rel='stylesheet' type='text/css'>
        <link href='http://fonts.googleapis.com/css?family=Monsieur+La+Doulaise' rel='stylesheet' type='text/css'>
        <script type="text/javascript" src="http://code.jquery.com/jquery-1.5.2.js"></script>

		<script src="/socket.io/socket.io.js"></script>
		<!--<script src="/public/socket.io.js"></script>-->
		<script type="text/javascript" src="/public/jquery.url.js"></script>
        <script type="text/javascript" src="/public/seed.js"></script>
        <script type="text/javascript" src="/public/filesaver.js"></script>
    </head>
    <body>

    	<div id="header">
    		<b>Dirty</b>Share
    	</div>

    	<script type="text/javascript">
            $(document).ready(function() {
	    		filth = 
					[
					 "\"My God, That\'s Filthy!\"", 
					 "\"You Dirty Bastards!\"", 
					 "\"Sheer And Utter Filth!\"", 
					 "\"What a Shame!\"", 
					];
				$('#subheader').html('<i>' + filth[Math.floor(Math.random()*filth.length)] + '</i>');
			});
		</script>

    	<div id="subheader">
    	</div>

    	<div id="description">
    		This is WebP2P version 0.1, aka 'DirtyShare', a pure JavaScript "peer to peer" filesharing system written in Node.js and Socket.io. Don't use this for anything. What's wrong with you?
    	</div>

            	<div id="drop_zone" onClick="$('#files').click()" >
            		<div id="clicky"><br /><br /><br /><br />Loading..</div>
            		<div id="fileslist">
            		
            		</div>
            	</div>
                <input type="file" id="files" name="files[]" multiple style="height: 20px; opacity: 0; filter:alpha(opacity: 0);  position: relative; top: -40px; left: -20px;" />
        	
        	<div id="infoholder">
	        	<div id="host">
		        </div>

		        <div id="peer">
		        	Awaiting peer..
		        </div>
		    </div>

        <script type="text/javascript">
            $(document).ready(function() {
                $('#shareurl').html('<b>http://${domain}/' + $.url().segment(1) + '</b>');
			});
		</script>

		<br />
        <div id="description">
    		Share this URL: <div id="shareurl"></div>
    	</div>

    	<div id="what">
 			<i><a onClick="$('#about').slideDown('slow');">What is this?</a><i>
    	</div>

    	<div id="about" style="display: none;">
 			<b>Dirty</b>Share is a proof of concept "Peer to Peer" filesharing system written in <b>pure Javascript</b> with Socket.io and Node.js. It's called <b>Dirty</b>Share because it's dirty as hell across the whole stack, from the concept to the code to the use case. <br/><br/>

 			File transfers in <b>Dirty</b>Share happen from a host client to a peer client, in chunks which go through the webserver over WebSockets provided by Socket.IO. The web server only holds onto the data while it is being received and transmitted through it, so there is <i>no data ever permanently stored on the web server</i>. This makes it perfect for sending dirty pictures!<br/><br/>

			Ideally, the WebSockets will only be used to establish the P2P connections which will go over the HTML5 PeerConnection object, however, <i>no modern browsers support this feature yet</i>. Hopefully, it will become available within the next 6 months or so, and <b>we will be ready</b> for it !<br /><br />

			Let's make a purely browser based, ad-free, Free and Open Source private filesharing system! 

    	</div>

    	<div id="credits">
    		<b>Dirty</b>Share is written by <b>Rich Jones</b> of <b><a href="http://gun.io" target="_blank">Gun.io</a></b>. <br/><br/>
    		<a href="https://github.com/Miserlou/DirtyShare" target="_blank">Source code</a> is here.<br/> Patches graciously accepted! <br/><br/>
    		Interested in dicussing/hacking on web peer to peer software? Shoot an email to <b>webp2p@librelist.com</b> and you'll be part of the mailing list!
    	</div>

        <div id="lower">
	        <div id="info">
	        </div>

	        <div id="warnings">
	        </div>
        </center>

		<script>

		var fid = 0;
		var files = {};
		var downfiles = {};
        var fileo = {};
        var arrfile;
		var socket = io.connect('http://${domain}');
		//read the requested bytes
		var reader;
		var canHost = true;
		if (typeof FileReader !== "undefined"){
			reader = new FileReader();
		}
		else{
			$('#clicky').html('<br /><br />Your browser is not modern enough to serve as a host. :( <br /><br />(Try Chrome or Firefox!)');
			canHost = false;
		}
		var chunksize = 65536;
		  
		socket.on('connect', function(data){
			socket.emit('joiner', $.url().segment(1));	
		});

		socket.on('fileslist', function(data){
			$('#fileslist').show();
			$('#clicky').html('');
			$('#clicky').hide();
			$('#fileslist').html('');
			$('#fileslist').html(function(i,v){
   				return '<table id="filestable" cellspacing="0" summary=""><tr><th scope="col" abbr="Filename" class="nobg" width="60%">Filename</th><th scope="col" abbr="Status" width="20%" >Size</th> <th scope="col" abbr="Size"width="20%" >Action</th></tr>' + v;
	   			});
	   		files = {};
			files = JSON.parse(data);

			for (var file in files) {
				console.log(files);
			  if (files.hasOwnProperty(file)) {
                  arrfile = files[file][3]; //expecting 1 file only, not more
                  /**
                   * Object
                        paul.mp3: Array[4]
                        0: "paul.mp3"
                        1: 5042722
                        2: "audio/mp3"
                        3: Object
                            lastModifiedDate: "2013-02-22T12:31:18.000Z"
                            name: "paul.mp3"
                            size: 5042722
                            type: "audio/mp3"
                            webkitRelativePath: ""
                   */
				$('#filestable').append('<tr><th scope="row" class="spec">' + files[file][0] + '</th><td>' + files[file][1] + '</td><td class="end" ><div id="fidspan' + fid + '"></div><a href="" onclick="beginTransfer(\'' + files[file][0] + '\', ' + fid + ', ' + files[file][1] + '); return false;" id="fid' + fid + '">Transfer</a><a href="data:' + files[file][2] + ';base64," target="_blank" id="fidsave' + fid + '" style="display:none">Save to disk!</a></td></tr>');
				fid++;
			  };
			}
		});

		socket.on('warn', function(data){
			$('#warnings').html(data);
		});

		socket.on('host', function(data){
			if(canHost){
				$('#host').html("You're hosting this party!");
				$('#clicky').html("<br /><br /><br /><br />Click here to choose files");
				$('#fileslist').hide();
			}
		});

		socket.on('peer', function(data){
			$('#peer').html("You're connected as a peer!");
			$('#host').html("Host connected.");
			$('#drop_zone').attr("onclick", function() { 
			    return;
			});
			$('#files').remove();
			$('#drop_zone').css("cursor", "default");
			$('#fileslist').hide();
			$('#clicky').html('Awaiting file list..');

		});

		socket.on('peerconnected', function(data){
			$('#peer').html("Peer connected!");
		});

		socket.on('peerdisconnected', function(data){
			$('#peer').html("Peer disconnected.");
		});

		socket.on('hostdisconnected', function(data){
			$('#host').html("Host disconnected.");
			$('#peer').html("You're disconnected!");
		});

		socket.on('info', function(data){
			$('#info').append(data);
		});

		socket.on('begintransfer', function(file, chunk){
			if(chunk == 0){
				$('#info').append("Begining Transfer..");
			}
            /**
             fileholder =
                 Array[4]
                 0: "paul.mp3"
                 1: 5042722
                 2: "audio/mp3"
                 3: Object
                     lastModifiedDate: "2013-02-22T12:31:18.000Z"
                     name: "paul.mp3"
                     size: 5042722
                     type: "audio/mp3"
                     webkitRelativePath: ""
            * */
			fileholder= files[file];
			fileo= files[file][3]; //ugly         //fileholder[3]
            myfiles= files[file][3]; //ugly         //fileholder[3]
            //console.log(myfiles);
			start = chunk * chunksize;

			if((parseInt(fileholder[1]) - 1) <= start + chunksize - 1){
				stop = parseInt(fileholder[1]) - 1;
                //start =    (chunk - 1) * chunksize; //added recently         no need when chunks number changed to chunks-1
			}
			else{
				stop = start + chunksize - 1;
			}

			// If we use onloadend, we need to check the readyState.
            // навешиваем обработчик на собатие которое еще не произщошло
			reader.onloadend = function(evt) {
			      if (evt.target.readyState == FileReader.DONE) { // DONE == 2
			        var data = evt.target.result;
                    //console.log(data);
			        socket.emit('datatransfer', data, file, chunk);
			      }
			};

			if (fileo.slice) {
			  var blob = fileo.slice(start, stop + 1);
			} else if (fileo.mozSlice) {
			  var blob = fileo.mozSlice(start, stop + 1);
			}
			else{
				alert("It won't work in your browser. Please use Chrome or Firefox.");
			}
			
			reader.readAsBinaryString(blob);
            //reader.readAsDataURL(blob);
			
		});

		socket.on('datatransfer', function(data, file, chunk){
            //alert("datatransfer-");
            console.log("dataTransfer " + " " + chunk);
			f = downfiles[file];
            //console.log(data);
            //data = decode64(data.split(',')[1]);
			//f.data = f.data + data;


            function onFsInit(fs){
                fs.root.getFile(arrfile['name'], {create: true}, function(fileEntry) {
                    //fileEntry.remove();
                    fileEntry.createWriter(function(fileWriter) {
                        fileWriter.onwriteend = function(e) {
                            console.log('Partial write.' + chunk + " of " + f.chunks + " chunks completed");
                            if(f.chunks == chunk){
                                console.log("completed");
                                window.location.href = fileEntry.toURL();
                            }
                        };

                        fileWriter.onerror = function(e) {
                            alert('Write failed: ' + e.toString());
                        };

                        //var bb = new BlobBuilder(); deprecated in favor of Blob
                        //var arr = new Array();
                        //arr.push("Lorem Ipsum");
                        //arr.push(" Doloris");
                        //var bb = new Blob([f.data],{type: arrfile['type']} );

                        //var bb = new Blob([f.data],{type: arrfile['type']} );
                        var bb = new Blob([data],{type: arrfile['type']} );
                        //var bb = new Blob([data],{type: 'application/octet-stream'} );
                        fileWriter.seek(fileWriter.length); // Start write position at EOF.
                        fileWriter.write(bb);
                        //saveAs(bb, "test.mp3");
                    }, errorHandler);
                }, errorHandler);
            }
            function errorHandler(e) {
                var msg = '';

                switch (e.code) {
                    case FileError.QUOTA_EXCEEDED_ERR:
                        msg = 'QUOTA_EXCEEDED_ERR';
                        break;
                    case FileError.NOT_FOUND_ERR:
                        msg = 'NOT_FOUND_ERR';
                        break;
                    case FileError.SECURITY_ERR:
                        msg = 'SECURITY_ERR';
                        break;
                    case FileError.INVALID_MODIFICATION_ERR:
                        msg = 'INVALID_MODIFICATION_ERR';
                        break;
                    case FileError.INVALID_STATE_ERR:
                        msg = 'INVALID_STATE_ERR';
                        break;
                    default:
                        msg = 'Unknown Error';
                        break;
                };

                alert('Error: ' + msg);
            }


            function fsInitErrorHandler(e){
                alert('unsuccessfull init' + e.code);
            }

            window.requestFileSystem = window.requestFileSystem || window.webkitRequestFileSystem;
            //if webkit
            if (window.webkitStorageInfo !== 'undefined')
                window.webkitStorageInfo.requestQuota(PERSISTENT, 1024*1024*800, function(grantedBytes) {
                    window.requestFileSystem(window.PERSISTENT,grantedBytes, onFsInit, fsInitErrorHandler);
                }, function(e) {
                    console.log('Error', e.toString());
                });
            else  {
                alert("Your browser doesn't support file api. Recently chrome is the only supported browser")
            }



            //конец загрузки
			if(f.chunks == chunk){
                /*var doc = window.document;
                var save_link = doc.createElementNS("http://www.w3.org/1999/xhtml", "a");
                var click = function(node) {
                    var event = doc.createEvent("MouseEvents");
                    event.initMouseEvent(
                            "click", true, false, window, 0, 0, 0, 0, 0
                            , false, false, false, false, 0, null
                    );
                    return node.dispatchEvent(event); // false if event was cancelled
                }*/
				var fspan = "#fidspan" + f.fid;
				$(fspan).html('');
				$(fspan).hide();

				var fsave = "#fidsave" + f.fid;
				$(fsave).show();
                /*var  get_URL = function() {
                    return window.URL || window.webkitURL || window;
                }
                var blob = new Blob([f.data],{type: "application/octet-stream"} );
                //alert(f.data.length + " " + blob.size);
                var get_object_url = function() {
                    var object_url = get_URL().createObjectURL(blob);
                    //deletion_queue.push(object_url);
                    return object_url;
                }*/
                //object_url = get_object_url(blob);

                /*save_link.href = object_url;
                save_link.download = 'tasty.mp3';
                if (click(save_link)) {


                    return;
                }
                */





				$(fsave).attr('href', $(fsave).attr('href') + encode64(f.data));
				$('#info').append("Transfer finished!");
			}
			else{
				var fspan = "#fidspan" + f.fid;
				$(fspan).html(Math.floor(((chunk/f.chunks) * 100)) + '%');
				var nextchunk = parseInt(chunk);
				socket.emit('begintransfer', file, nextchunk+1);
			}
		});
			
		function beginTransfer(file, fid, size){

			var f = "#fidspan" + fid;
			$(f).html('0%');
			f = "#fid" + fid;
			$(f).hide();

			var chunks = size/chunksize -1;
			if(chunks% 1 != 0){
				chunks = Math.floor(chunks) + 1;
			}

			downfiles[file] = {data:'', chunk:0, chunks:chunks, fid:fid};
			socket.emit('begintransfer', file, 0);
		};

		function handleFileSelect(evt) {
			var viles = evt.target.files; // FileList object
			files = {};

			// Loop through the FileList and append files to list.
			for (var i = 0, f; f = viles[i]; i++) {
				if (!files.hasOwnProperty(f)) {
					files[f.name] = [f.name, f.size, f.type, f];
				};
			}
		    socket.emit('listfiles', JSON.stringify(files));

		    $('#fileslist').show();
			$('#clicky').html('');
			$('#clicky').hide();
			$('#fileslist').html('');
			$('#fileslist').html(function(i,v){
   				return '<table id="filestable" cellspacing="0" summary=""><tr><th scope="col" abbr="Filename" class="nobg" width="60%">Filename</th><th scope="col" abbr="Status" width="20%" >Size</th> <th scope="col" abbr="Size"width="20%" >Action</th></tr>' + v;
	   			});
			for (var file in files) {
			  if (files.hasOwnProperty(file)) {
				$('#filestable').append('<tr><th scope="row" class="spec">' + files[file][0] + '</th><td>' + files[file][1] + '</td><td class="end"><b>Sharing!</b></td></tr>');
			  }
			}
		}

		document.getElementById('files').addEventListener('change', handleFileSelect, false);

   var keyStr = "ABCDEFGHIJKLMNOP" +
                "QRSTUVWXYZabcdef" +
                "ghijklmnopqrstuv" +
                "wxyz0123456789+/" +
                "=";

   function encode64(input) {
      var output = "";
      var chr1, chr2, chr3 = "";
      var enc1, enc2, enc3, enc4 = "";
      var i = 0;

      do {
         chr1 = input.charCodeAt(i++);
         chr2 = input.charCodeAt(i++);
         chr3 = input.charCodeAt(i++);

         enc1 = chr1 >> 2;
         enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);
         enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);
         enc4 = chr3 & 63;

         if (isNaN(chr2)) {
            enc3 = enc4 = 64;
         } else if (isNaN(chr3)) {
            enc4 = 64;
         }

         output = output +
            keyStr.charAt(enc1) +
            keyStr.charAt(enc2) +
            keyStr.charAt(enc3) +
            keyStr.charAt(enc4);
         chr1 = chr2 = chr3 = "";
         enc1 = enc2 = enc3 = enc4 = "";
      } while (i < input.length);

      return output;
   }

        function decode64(input) {
            var output = "";
            var chr1, chr2, chr3 = "";
            var enc1, enc2, enc3, enc4 = "";
            var i = 0;

            // remove all characters that are not A-Z, a-z, 0-9, +, /, or =
            var base64test = /[^A-Za-z0-9\+\/\=]/g;
            if (base64test.exec(input)) {
                alert("There were invalid base64 characters in the input text.\n" +
                        "Valid base64 characters are A-Z, a-z, 0-9, '+', '/',and '='\n" +
                        "Expect errors in decoding.");
            }
            input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");

            do {
                enc1 = keyStr.indexOf(input.charAt(i++));
                enc2 = keyStr.indexOf(input.charAt(i++));
                enc3 = keyStr.indexOf(input.charAt(i++));
                enc4 = keyStr.indexOf(input.charAt(i++));

                chr1 = (enc1 << 2) | (enc2 >> 4);
                chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
                chr3 = ((enc3 & 3) << 6) | enc4;

                output = output + String.fromCharCode(chr1);

                if (enc3 != 64) {
                    output = output + String.fromCharCode(chr2);
                }
                if (enc4 != 64) {
                    output = output + String.fromCharCode(chr3);
                }

                chr1 = chr2 = chr3 = "";
                enc1 = enc2 = enc3 = enc4 = "";

            } while (i < input.length);

            return unescape(output);
        }
   </script>

    </body>
</html>
